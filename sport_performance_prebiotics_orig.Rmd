---
title: 'Personalized fiber intake increases exercise performance in healthy individuals.'
author: "A. Umanets"
date: "`r date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r , message=FALSE, warning=FALSE, prompt=FALSE, results='hide', echo=FALSE}
#-------------------------------------------------------------------------------
# Libraries and data 
#-------------------------------------------------------------------------------
set.seed(549794)

lib.to.load <- c("phyloseq", "tidyverse", "FSA", 
                  "ggsignif", "broom", "psych", "lme4", 
                  "vegan", "cowplot", "Maaslin2", "knitr", 
                  "emmeans", "qiime2R", "metagenomeSeq")

for (i in lib.to.load) {library(i, character.only = TRUE)}

source("R/phy_pcoa_plot.R")
source("R/phy_shorten_tax_names.R")
source("R/phy_dbrda_plot.R")
source("R/filt_tax_phy.R")
source("R/chisq_test_df.R")
```



```{r , message=FALSE, warning=FALSE, prompt=FALSE, results='hide', echo=FALSE}
#------------------------------------------------------------------------------
# Data import
#------------------------------------------------------------------------------
# Import data into phyloseq 
ps.0 <- qza_to_phyloseq(features = "data/asv_table.qza", 
                        tree = "data/tree/unrooted-tree.qza", 
                        taxonomy = "data/taxonomy_07.qza")


ps.meta <- read.csv("data/sp_metadata.csv") %>% 
            mutate(SeqID = X) %>% 
            column_to_rownames("X")


sample_data(ps.0) <- ps.meta


#-------------------------------------------------------------------------------
# Filter out very rare (artifacts) and contaminating taxa
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Prune taxa 
#-------------------------------------------------------------------------------
# Taxa with less than 10 reads in total   
ps1 <- prune_taxa(taxa_sums(ps.0) > 10, ps.0)

# Remove ASVs: 
# Kingdom: "d__Eukaryota", "Unassigned"
# Genus: "Mitochondria"
ps1 <- prune_taxa(!tax_table(ps1)[, "Genus"] %in% "Mitochondria", ps1)

ps1 <- prune_taxa(!tax_table(ps1)[, "Kingdom"] %in% c("d__Eukaryota", "Unassigned"), 
                      ps1)

#-------------------------------------------------------------------------------
# Make telling names 
#-------------------------------------------------------------------------------
taxa_names(ps1) <- phy_shorten_tax_names(ps1) %>% 
                        gsub("_group", "", .) %>% 
                        paste0(., "_asv", 1:length(taxa_names(ps1)))


# Genus level
ps1.genus <- tax_glom(ps1, "Genus")

taxa_names(ps1.genus) <- phy_shorten_tax_names(ps1.genus) %>% 
                        gsub("_group", "", .) %>% 
                        make.unique()


#-------------------------------------------------------------------------------
# Phylseqs list
#-------------------------------------------------------------------------------

# CSS - ASV
ps1.css.asv <- ps1

otu_table(ps1.css.asv) <- ps1 %>% 
                              phyloseq_to_metagenomeSeq(.) %>% 
                              cumNorm(., p=cumNormStatFast(.)) %>% 
                              MRcounts(., norm=TRUE, log=TRUE) %>% 
                              as.data.frame() %>% 
                              otu_table(., taxa_are_rows = TRUE)


# CSS - Genus
ps1.css.genus <- ps1.genus

otu_table(ps1.css.genus) <- ps1.genus %>%
                                phyloseq_to_metagenomeSeq(.) %>%
                                cumNorm(., p=cumNormStatFast(.)) %>%
                                MRcounts(., norm=TRUE, log=TRUE) %>%
                                as.data.frame() %>%
                                otu_table(., taxa_are_rows = TRUE)
```

```{r , message=FALSE, warning=FALSE, prompt=FALSE, results='hide', echo=FALSE}

# Normalize count
ps1.rare <- rarefy_even_depth(ps1, rngseed = 0745048)

#-------------------------------------------------------------------------------
# Columns 
#-------------------------------------------------------------------------------
Time_point <- "Timepoint"
Group <- "Group"
PersonID <- "Rnr"
Age <- "Age"
Sex <- "M_F"
Perfomance <- "TTE"
col.to.numeric <- "SCFA|Kcal|Fibers|Age|VO|TTE|GSRS|IPAQ|BSC"
col.to.factors <- c(Time_point, Group, PersonID, Sex)
cor.prev.cut <- 0.5
cor.method <- "spearman"

#----------------------------------------------------------------------------------------
# General adjustments 
#-----------------------------------------------------------------------------------------
ps1.meta <- ps.meta %>% 
                mutate_at(vars(matches(col.to.numeric)), as.numeric) %>% 
                mutate_at(col.to.factors, as.factor)


#-------------------------------------------------------------------------------
# Color schema 
#-------------------------------------------------------------------------------
# Groups color
col.time.point <- RColorBrewer::brewer.pal(7, "Dark2")[c(1,3)]

names(col.time.point) <- levels(ps1.meta[, Time_point])

col.gr <- RColorBrewer::brewer.pal(7, "Set1")[c(2, 7)]

names(col.gr) <- levels(ps1.meta[, Group])

#-------------------------------------------------------------------------------
# Maaslin Variables 
#-------------------------------------------------------------------------------
maaslin.prev.cut <- 0.25

maaslin.norm.method = "CSS"

maaslin.tranf.method = "LOG"

maaslin.analysis.method = "LM"

alpha <- 0.1
```

# Diferences in performance between groups.

##  Independes test and dirstribution of variables {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
# Chi-square independence test
#-------------------------------------------------------------------------------
chi.res <- ps1.meta %>% 
           select(c(Sex, Group, Time_point, Age)) %>% 
           chisq_test_df()

#-------------------------------------------------------------------------------
# Samples distribution per variable 
#-------------------------------------------------------------------------------
# Add log transformed TTE 
tte.hist <- ggplot(ps1.meta, aes_string(x=Perfomance)) + 
                  geom_histogram() 

var.hist <- ps1.meta %>% 
           select(c(Sex, Group, Time_point, Age)) %>%
            gather(., key, value, -all_of(Time_point)) %>% 
            ggplot(., aes(x=value)) + 
                facet_wrap(get(Time_point) ~ key, scales = "free") + 
                geom_histogram(stat = "count")
```

### Chi-square 

**Table.** Results of Chi-square correlation test between variables. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
kable(chi.res)
```

### TTE distribution

**Figure.** The histogram shows distribution of time to exhaustion (TTE) in all samples. Both results, at T1 and T3, are displayed. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
tte.hist
```

### Variables distribution

**Figure.** Distribution of samples per variable. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
var.hist
```

## Primary outcome

**Methods** \
Linear mix effect model was employed to test significance in performance before and after intervention. The model was build using *lmerTest* R package that extend the *lme4* and estimates p-values. We used Sex, Age, Time and Group as independent variables and Participant ID as a random effect nested within the Group variable. We focused our analysis on interaction between independent variables Group and Time. The following formal was used to build the model: \
*Performance ~ Sex + Age + Group\*Timepoint + (1|Group/PersonID)* \
Pairwise compression of the model terms (Group and Time) was performed as implemented in *emmins* R package using following formula: \
*pairwise ~ Timepoint|Group* \
P-values obtained in pairwise comparison were reported in the corresponding figures. \ 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
mod.rand.full <- paste0(Perfomance, "~", Sex, "+", Age, "+", 
                   Group, "*", Time_point, "+", 
                   "(1|", PersonID, ")") 

r.mod.full <- lmerTest::lmer(mod.rand.full, data = ps1.meta)
```

### LMM Results {.tabset}

#### Model summary 

**Table** Statistical summary of the model. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
mod.sum <- summary(r.mod.full)

mod.sum
```

#### Pairwise summary  

**Table** Pairwise summary of contrasted variables Group and Time Point. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
paired.mod.sum <- emmeans(r.mod.full, 
                                   pairwise ~ Timepoint|Group, 
                                   type = "response")
paired.mod.sum
```

#### Assumption 1. 

**Figure** Homogeneity of variance plot. \
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3, fig.width=5}
plot(r.mod.full)
```

#### Assumption 2. 

**Figure** QQ plot of the residuals. \
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3, fig.width=5}
tdat <- data.frame(predicted=predict(r.mod.full), 
                   residual = residuals(r.mod.full))

ggplot(tdat,aes(sample=residual)) + 
  stat_qq() + 
  stat_qq_line() + 
  theme_bw()
```

### Performance visualization {.tabset}

#### Box plot V1

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3.5, fig.width=6}

ps1.meta$TTE_Change <- ifelse(ps1.meta$Delta_TTE == 0, "No_Change", 
                                 ifelse(ps1.meta$Delta_TTE > 0, "Increase", "Decrease"))

# Data for significance 
max.div <- ps1.meta %>% 
                dplyr::select(c("TTE", "Group")) %>% 
                group_by(Group) %>% 
                slice(which.max(TTE)) %>% 
                mutate(y.adj = (TTE*1.1))
  
sig.df <- paired.mod.sum$contrasts %>% 
              as.data.frame() %>% 
              mutate(p.short = paste0("p=", round(p.value, 3)), 
                     Start = sub(" -.*", "", contrast), 
                     End = sub(".* - ", "", contrast)) %>% 
              left_join(., max.div, by = "Group")
  

# Plot data
perf.dif <- ggplot(ps1.meta, aes_string(y = Perfomance, x = Time_point)) + 
                  geom_point(aes_string(color = "TTE_Change"), 
                             size = 2, 
                             alpha = 1) +
                  geom_line(aes_string(group = PersonID, 
                                       color = "TTE_Change"), 
                            alpha = 0.5, 
                            size = 0.6) + 
                  geom_boxplot(fill = NA, 
                               alpha = 0.1, 
                               fatten = 0.5) +
                  stat_summary(fun.y=mean, 
                               geom="point", 
                               shape=18, 
                               size=4, 
                               color="black", 
                               fill="black") +
                  geom_signif(data = sig.df,
                                aes(xmin = Start,
                                    xmax = End,
                                    annotations = p.short,
                                    y_position = y.adj),
                                textsize = 4, vjust = -0.1,
                                manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                                aes(x = End, y = y.adj*1.1), x=NA) +
                  facet_grid(~ Group) + 
                  theme_bw() + 
                  scale_color_manual(values = c(Increase = "forestgreen", 
                                                Decrease = "firebrick3", 
                                                No_Change = "grey50")) 
                  

perf.dif
```

#### Box plot V2

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3.5, fig.width=6}

# Data for significance 
max.div <- ps1.meta %>% 
                dplyr::select(c("TTE", "Group")) %>% 
                group_by(Group) %>% 
                slice(which.max(TTE)) %>% 
                mutate(y.adj = (TTE*1.1))
  
sig.df <- paired.mod.sum$contrasts %>% 
              as.data.frame() %>% 
              mutate(p.short = paste0("p=", round(p.value, 3)), 
                     Start = sub(" -.*", "", contrast), 
                     End = sub(".* - ", "", contrast)) %>% 
              left_join(., max.div, by = "Group")
  

# Plot data
perf.dif <- ggplot(ps1.meta, aes_string(y = Perfomance, x = Time_point)) + 
                  geom_boxplot(fill = NA, 
                               alpha = 0.1, 
                               fatten = 0.5) +
                  stat_summary(fun.y=mean, 
                               geom="point", 
                               shape=18, 
                               size=4, 
                               color="black", 
                               fill="black") +
                  geom_signif(data = sig.df,
                                aes(xmin = Start,
                                    xmax = End,
                                    annotations = p.short,
                                    y_position = y.adj),
                                textsize = 4, vjust = -0.1,
                                manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                                aes(x = End, y = y.adj*1.1), x=NA) +
                  facet_grid(~ Group) + 
                  theme_bw()
                  

perf.dif
```


#### Line plot 

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3.5, fig.width=6}
# Data for significance 
max.div <- ps1.meta %>% 
                dplyr::select(c("TTE", "Group", "Timepoint")) %>% 
                group_by(Group, Timepoint) %>% 
                mutate(y.adj = (mean(TTE) + sd(TTE)*1.5)) %>% 
                group_by(Group) %>% 
                slice(which.max(y.adj))
  
sig.df <- paired.mod.sum$contrasts %>% 
              as.data.frame() %>% 
              mutate(p.short = paste0("p=", round(p.value, 3)), 
                     Start = sub(" -.*", "", contrast), 
                     End = sub(".* - ", "", contrast)) %>% 
              left_join(., max.div, by = "Group")
  

# Plot data

perf.dif <- ps1.meta %>% 
              group_by(Timepoint, Group) %>% 
              summarise(Mean = mean(TTE), 
                        SD = sd(TTE, na.rm = TRUE)) %>% 
              ggplot(., aes(y = Mean, x = Timepoint)) + 
                  geom_point(size = 3)+
                  geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), 
                                width=.2,
                                position=position_dodge(0.05)) +
                  geom_signif(data = sig.df,
                                aes(xmin = Start,
                                    xmax = End,
                                    annotations = p.short,
                                    y_position = y.adj),
                                textsize = 4, vjust = -0.1,
                                manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                                aes(x = End, y = y.adj*1.1), x=NA) +
                  facet_grid(~ Group) + 
                  theme_bw() + 
                  ylab(label = "TEE")

perf.dif
```

#### Dynamite plot 

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=3.5, fig.width=6}
# Data for significance 
max.div <- ps1.meta %>% 
                dplyr::select(c("TTE", "Group", "Timepoint")) %>% 
                group_by(Group, Timepoint) %>% 
                mutate(y.adj = (mean(TTE) + sd(TTE)*1.5)) %>% 
                group_by(Group) %>% 
                slice(which.max(y.adj))
  
sig.df <- paired.mod.sum$contrasts %>% 
              as.data.frame() %>% 
              mutate(p.short = paste0("p=", round(p.value, 3)), 
                     Start = sub(" -.*", "", contrast), 
                     End = sub(".* - ", "", contrast)) %>% 
              left_join(., max.div, by = "Group")
  

# Plot data
perf.dif <- ps1.meta %>% 
              group_by(Timepoint, Group) %>% 
              summarise(Mean = mean(TTE), 
                        SD = sd(TTE, na.rm = TRUE)) %>% 
              ggplot(., aes(y = Mean, x = Timepoint, fill = Timepoint)) + 
                   geom_bar(position=position_dodge(), stat="identity",
                            colour='black', width = 0.7) +
                  geom_errorbar(aes(ymin=Mean-SD, ymax=Mean+SD), 
                                width=.2,
                                position=position_dodge(0.05)) +
                  geom_signif(data = sig.df,
                                aes(xmin = Start,
                                    xmax = End,
                                    annotations = p.short,
                                    y_position = y.adj),
                                textsize = 4, vjust = -0.1,
                                manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                                aes(x = End, y = y.adj*1.1), x=NA) +
                  facet_grid(~ Group) + 
                  theme_bw() + 
                  scale_fill_manual(values = col.time.point) + 
                  ylab(label = "TEE")
                  

perf.dif
```

# Diferences in alpha diversity between groups {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
# Prepare data and calculate alpha diversity
#-------------------------------------------------------------------------------
# Calculate diversity indexes 
alpha.df <- estimate_richness(physeq = ps1.rare, 
                  measures = c("Observed", "Shannon", "InvSimpson"))

# Calculate Phylogeny Diversity (package "picante")
alpha.df$PhyloDiverity <- picante::pd(samp = t(otu_table(ps1.rare)), 
                                       tree = phy_tree(ps1.rare), 
                                       include.root = FALSE) |>
                          select("PD") |> 
                          unlist()

# Add relevant columns 
alpha.df.long <- ps1.meta |> 
                    select(c(Time_point, Group, PersonID)) |> 
                    bind_cols(alpha.df) |>
                    gather(key = "Diversity_Index", 
                           value = "Value", 
                           -all_of(c(Time_point, Group, PersonID))) 

#-------------------------------------------------------------------------------
# Pairwise comparison of Alpha diversity per group at TD1 vs TD3
#-------------------------------------------------------------------------------
# 1. Prepare data 
# Remove samples without a pairs > sort samples
alpha.df <- alpha.df.long %>% 
                    group_by(across(c(PersonID, "Diversity_Index"))) %>% 
                    filter(n() == 2)  %>%  
                    group_by(across(c(Time_point, "Diversity_Index", Group))) %>% 
                    arrange(get(PersonID)) 

# Get names for each group                     
gr.names <- alpha.df |> 
              group_keys() |> 
              unite(col = grNames, sep = "_") |> 
              pull()

# Split into a list and assign names 
alpha.ls <- alpha.df |> 
                  group_split() |> 
                  setNames(gr.names)


# 2. Test (Paired Wilcoxon)
res <- NULL

for (i in c("Observed", "Shannon", "InvSimpson", "PhyloDiverity")) {
  
  div.ls <- alpha.ls[grep(i, names(alpha.ls))]
  
  for (i1 in c("GR1", "GR2")) {
    
    div.gr.ls <- div.ls[grep(i1, names(div.ls))]
    
    td1.v <- div.gr.ls[[paste("TD1", i, i1, sep = "_")]] |> 
              pull(Value)
    
    td3.v <- div.gr.ls[[paste("TD3", i, i1, sep = "_")]] |> 
              pull(Value)
    
    res <- wilcox.test(td1.v, td3.v, paired = TRUE) %>% 
               tidy() %>% 
               select(c("p.value")) %>% 
               mutate(Comparison = "TD1_vs_TD3", Group = i1, DivIndex = i) %>% 
               rbind(res, .)
    
  }
  
}

```

## Statistics

**Table.** Results of paired Wilcoxon test comparison between T1 and T2. Comparison was performed separately for Control and Treatment group. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
kable(res)
```

## Plot V1

**Figure** The boxplot depicts Microbial diversity (Alpha diversity) indexes before and after intervention in Control and Treatment groups. Black dots represent individual samples and gray lines connect results of individuals before and after intervention.\
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=5.5, fig.height=6.5}
#-------------------------------------------------------------------------------
# Plot Alpha diversity 
#-------------------------------------------------------------------------------
# Make data frame for significance levels 
max.div <- alpha.df.long %>% 
              group_by(across(c(Group, "Diversity_Index"))) %>% 
              slice(which.max(Value)) %>% 
              mutate(Id = paste0(Diversity_Index, "_", Group), 
                     End = if_else(Timepoint == "TD1", "TD3", "TD1"), 
                     y = Value*1.1)

sig.df <- res %>% 
            mutate(Id = paste0(DivIndex, "_", Group), 
                   p.short = paste0("p=", round(p.value, 3))) %>% 
            filter(p.value <= 0.05) %>% 
            left_join(., max.div)

# Plot alpha diversity 
alpha.plot <- ggplot(alpha.df.long, aes_string(y = "Value", x = Time_point)) + 
                  geom_point(size = 2, alpha = 1) +
                  geom_line(aes_string(group = PersonID), alpha = 0.25) + 
                  geom_boxplot(fill = NA, alpha = 0.1) +
                  geom_signif(data = sig.df,
                              aes(xmin = Timepoint,
                                  xmax = End,
                                  annotations = p.short,
                                  y_position = y),
                              textsize = 4, vjust = -0.1,
                              manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                              aes(x = End, y = y*1.175), x=NA) +
                  facet_grid(Diversity_Index ~ Group, scales = "free") + 
                  theme_bw()

alpha.plot 
```

## Plot V2

**Figure** The boxplot depicts Microbial diversity (Alpha diversity) indexes before and after intervention in Control and Treatment groups. \
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=5.5, fig.height=6.5}
#-------------------------------------------------------------------------------
# Plot Alpha diversity 
#-------------------------------------------------------------------------------
# Make data frame for significance levels 
max.div <- alpha.df.long %>% 
              group_by(across(c(Group, "Diversity_Index"))) %>% 
              slice(which.max(Value)) %>% 
              mutate(Id = paste0(Diversity_Index, "_", Group), 
                     End = if_else(Timepoint == "TD1", "TD3", "TD1"), 
                     y = Value*1.1)

sig.df <- res %>% 
            mutate(Id = paste0(DivIndex, "_", Group), 
                   p.short = paste0("p=", round(p.value, 3))) %>% 
            filter(p.value <= 0.05) %>% 
            left_join(., max.div)

# Plot alpha diversity 
alpha.plot <- ggplot(alpha.df.long, aes_string(y = "Value", x = Time_point)) + 
                  geom_boxplot(fill = NA, alpha = 0.1) +
                  geom_signif(data = sig.df,
                              aes(xmin = Timepoint,
                                  xmax = End,
                                  annotations = p.short,
                                  y_position = y),
                              textsize = 4, vjust = -0.1,
                              manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                              aes(x = End, y = y*1.175), x=NA) +
                  facet_grid(Diversity_Index ~ Group, scales = "free") + 
                  theme_bw()

alpha.plot
```

# Diferences in beta diversity

## Combined model 

### Statistics 

#### ASV level {.tabset}

##### Fit Timepoint 

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- "dist.inst ~ Rnr + Group*Timepoint"

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### TTE fit (random effect)

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ Rnr + TTE")

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}


# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### TTE fit (NO random effect)

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ ", "TTE")

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

#### Genus level {.tabset}

##### Fit Timepoint 

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- "dist.inst ~ Rnr + Group*Timepoint"

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### TTE fit (random effect)

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ Rnr + TTE")

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}


# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### TTE fit (NO random effect)

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ ", "TTE")

res.adonis.comb <- list()

for (i in used.dist) {
  
  dist.inst <- distance(ps.var, method = i, type = "samples")
  
  res.adonis.comb[[paste0("ADONIS: ", i)]] <- adonis2(formula = as.formula(adonis.formula), 
                                      data = ps1.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i)
}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```


### Plots

#### ASV level {.tabset}

##### PCoA no color 

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.asv)
```

##### PCoA Group_Time

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.asv, 
              group_column = "GR_TD", 
              centroinds = FALSE, 
              hulls = TRUE) 
```

##### PCoA Time

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.asv, group_column = "Timepoint") + 
              scale_color_manual(values = col.time.point) + 
              scale_fill_manual(values = col.time.point)
```

##### PCoA Group

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.asv, group_column = "Group")   + 
              scale_color_manual(values = col.gr) + 
              scale_fill_manual(values = col.gr)
```

##### dbRDA

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_dbrda_plot(ps1.css.asv, 
               color_column = "GR_TD", 
               rda_formula = "Group*Timepoint")
```

#### Genus level {.tabset}

##### PCoA no color 

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.genus)
```

##### PCoA Group_Time

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.genus, 
              group_column = "GR_TD", 
              centroinds = FALSE, 
              hulls = TRUE) 
```

##### PCoA Time

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.genus, group_column = "Timepoint") + 
              scale_color_manual(values = col.time.point) + 
              scale_fill_manual(values = col.time.point)
```

##### PCoA Group

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_pcoa_plot(ps1.css.genus, group_column = "Group")   + 
              scale_color_manual(values = col.gr) + 
              scale_fill_manual(values = col.gr)
```

##### dbRDA

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
phy_dbrda_plot(ps1.css.genus, 
               color_column = "GR_TD", 
               rda_formula = "Group*Timepoint")
```


## Stratified

### Statistics

#### ASV level {.tabset}

##### by Group 

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ Rnr + Timepoint")

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$Group)) {
    
     i.ps <- prune_samples(ps.meta$Group == i.gr, ps.var)
     
     i.meta <- ps.meta[ps.meta$Group == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### by Timepoint

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ ", Group)

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$Timepoint)) {
    
     i.ps <- prune_samples(ps.meta$Timepoint == i.gr, ps.var)
     
     i.meta <- ps.meta[ps.meta$Timepoint == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```


##### TTE by GR_TD

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.asv

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- "dist.inst ~ TTE"

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$GR_TD)) {
    
     i.ps <- prune_samples(ps1.meta$GR_TD == i.gr, ps.var)
     
     i.meta <- ps.meta[ps1.meta$GR_TD == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

#### Genus level {.tabset}

##### by Group 

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------
ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ Rnr + Timepoint")

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$Group)) {
    
     i.ps <- prune_samples(ps.meta$Group == i.gr, ps.var)
     
     i.meta <- ps.meta[ps.meta$Group == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### by Timepoint

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- paste0("dist.inst ~ ", Group)

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$Timepoint)) {
    
     i.ps <- prune_samples(ps.meta$Timepoint == i.gr, ps.var)
     
     i.meta <- ps.meta[ps.meta$Timepoint == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

##### TTE by GR_TD

```{r , message=FALSE, warning=FALSE, echo=FALSE, results='asis'}
#-------------------------------------------------------------------------------
# Fit ADONIS model to beta diversity ordination
#-------------------------------------------------------------------------------

ps.var <- ps1.css.genus

# Calculate distances and statistically test
used.dist <- c("unifrac", "wunifrac", "jaccard", "bray")

# Formula for ADONIS testing
adonis.formula <- "dist.inst ~ TTE"

res.adonis.comb <- list()

for (i.dist in used.dist) {
   
  for (i.gr in unique(ps.meta$GR_TD)) {
    
     i.ps <- prune_samples(ps1.meta$GR_TD == i.gr, ps.var)
     
     i.meta <- ps.meta[ps1.meta$GR_TD == i.gr, ]
    
     dist.inst <- distance(i.ps, method = i.dist, type = "samples")
     
     res.adonis <- adonis2(formula = as.formula(adonis.formula), 
                                      data = i.meta, 
                                      by = "terms", 
                                      permutations = 999, 
                                      parallel = 4) %>% 
                            tidy() %>% 
                            mutate(Distance = i.dist, 
                                   Group = i.gr)
  
    res.adonis.comb[[paste0("ADONIS: ", i.gr, "_", i.dist)]] <- res.adonis
    
    
  }

}

# Print res
for (i in names(res.adonis.comb)) {
  
  print(kable(res.adonis.comb[[i]], caption = i ))
  
}
```

### Plots

#### ASV level {.tabset}

##### PCoA GR1

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Group == "GR1", ps1.css.asv)
  
phy_pcoa_plot(ps.gr, group_column = "Timepoint") + 
  scale_color_manual(values = col.time.point) + 
  scale_fill_manual(values = col.time.point)
```

##### PCoA GR2

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Group == "GR2", ps1.css.asv)
  
phy_pcoa_plot(ps.gr, group_column = "Timepoint") + 
  scale_color_manual(values = col.time.point) + 
  scale_fill_manual(values = col.time.point)
```

##### PCoA T1

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Timepoint == "TD1", ps1.css.asv)
  
phy_pcoa_plot(ps.gr, group_column = "Group") + 
  scale_color_manual(values = col.gr) + 
  scale_fill_manual(values = col.gr)
```

##### PCoA T2

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Timepoint == "TD3", ps1.css.asv)
  
phy_pcoa_plot(ps.gr, group_column = "Group") + 
  scale_color_manual(values = col.gr) + 
  scale_fill_manual(values = col.gr)
```

#### Genus level {.tabset}

##### PCoA GR1

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Group == "GR1", ps1.css.genus)
  
phy_pcoa_plot(ps.gr, group_column = "Timepoint") + 
  scale_color_manual(values = col.time.point) + 
  scale_fill_manual(values = col.time.point)
```

##### PCoA GR2

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Group == "GR2", ps1.css.genus)
  
phy_pcoa_plot(ps.gr, group_column = "Timepoint") + 
  scale_color_manual(values = col.time.point) + 
  scale_fill_manual(values = col.time.point)
```

##### PCoA T1

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Timepoint == "TD1", ps1.css.genus)
  
phy_pcoa_plot(ps.gr, group_column = "Group") + 
  scale_color_manual(values = col.gr) + 
  scale_fill_manual(values = col.gr)
```

##### PCoA T2

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=7, fig.height=5}
ps.gr <- prune_samples(ps.meta$Timepoint == "TD3", ps1.css.genus)
  
phy_pcoa_plot(ps.gr, group_column = "Group") + 
  scale_color_manual(values = col.gr) + 
  scale_fill_manual(values = col.gr)
```

# Differential abundance 

## ASV level {.tabset}

```{r , message=FALSE, warning=FALSE, results='hide', echo=FALSE}
#-------------------------------------------------------------------------------
# MAASLIN: Extract data
#-------------------------------------------------------------------------------
# Filter out taxa that are prevalent in less than 25% 
out.folder <- "out/maaslin_final/"
dir.create(out.folder, recursive = TRUE)

res.maas.long <-NULL

for (i in unique(ps.meta[, Group]))  {
  
  ps.gr <- prune_samples(ps.meta[, Group] == i, ps1)
  
  ps.gr <- tax_filt_phy(ps.gr, prev = maaslin.prev.cut, 
                        group_col = Time_point)
  
  ps.gr.asv <- ps.gr %>% 
                otu_table()  %>% 
                as.matrix()  %>% 
                as.data.frame() 
  
  ps.gr.meta <- ps.meta[ps1.meta[, Group] == i, ]
  
  maas.out <- Maaslin2(
                        input_data =  ps.gr.asv, 
                        input_metadata = ps.gr.meta, 
                        output = paste0(out.folder, i), 
                        fixed_effects = c(Time_point), 
                        random_effects = PersonID, 
                        reference = paste0(Time_point, ",", "TD1"), 
                        correction = "BH", 
                        cores = 4, 
                        min_abundance = 0, 
                        min_prevalence = 0, 
                        min_variance = 0, 
                        normalization = maaslin.norm.method, 
                        transform = maaslin.tranf.method, 
                        analysis_method = maaslin.analysis.method, 
                        max_significance = alpha)
  

res.maas.long <- rbind(res.maas.long, cbind(maas.out$results, Strata = i))  

}
```

### Results table

**Table** The ASVs with significant changes between T1 and T3 as determine by MaAsLin2. Control and Treatment group were analysed separately. Only ASV with prevalence more than 25% in a time point were tested. Participant IDs were used as a random effect. 
```{r , message=FALSE, warning=FALSE, echo=FALSE}
print.tab <- res.maas.long[res.maas.long$qval < alpha, ]

kable(print.tab)
```

### Results cofficient figure

**Figure** Visualization of the MaAsLin2 results. On the x-axis shown the coefficient of the abundance change after intervention on ASV level. \
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=4.5, fig.height=3}
res.maas.long <- res.maas.long[res.maas.long$qval < alpha, ]

maas.plot <- ggplot(res.maas.long, 
                        aes(x = coef, y = feature)) + 
                        geom_segment(aes(x = 0, xend = coef, 
                                     y = feature, yend = feature), 
                                     color = "black", alpha = 0.75) + 
                        geom_vline(xintercept = 0, alpha = 0.75) + 
                        geom_point(size = 3.5, alpha = 0.9) + 
                        facet_grid(. ~ Strata) + 
                        theme_bw() +
                        theme(panel.grid.major.x = element_blank(),
                              panel.grid.minor.x = element_blank(), 
                              axis.text.y = element_text(face = "italic")) +
                        ylab("") + xlab("Coeficient")

maas.plot
```

### Results boxplot

**Figure.** Box plots show relative abundance of ASVs identified as significantly different before and after intervention by MaAsLin2 per treatment group. \

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=6, fig.width=4}
#-------------------------------------------------------------------------------
# Significant taxa as boxplots 
#-------------------------------------------------------------------------------
# Prepare data for plotting
da.taxa.df <- prune_taxa(res.maas.long$feature, ps1.css.asv) %>% 
              otu_table() %>%
              as.matrix() %>% 
              as.data.frame() %>% 
              mutate(Taxa = rownames(.)) %>% 
              gather(key = "SeqID", value = "Abundance", -Taxa) %>% 
              left_join(., mutate(ps1.meta, 
                                  SeqID=rownames(ps1.meta))[, c("SeqID", 
                                                                "Group", 
                                                                "Timepoint")], 
                          by = "SeqID") 


dif.abund.tax <- ggplot(da.taxa.df, aes_string(y = "Abundance", 
                                               x = "Timepoint")) + 
                  geom_jitter(aes_string(color = "Timepoint"), size = 2, 
                              alpha = 0.5, width = 0.25, height = 0) +
                  geom_boxplot(fill = "black", alpha = 0.1, outlier.colour = NA) +
                  facet_grid(c( "Taxa", "Group"), scales = "free") + 
                  theme_bw() + 
                  scale_color_manual(values = col.time.point) + 
                  theme(legend.position = "none") + ylab("Abundance (CSS)") + 
                  theme(strip.text.y = element_text(size = 4))

dif.abund.tax

```

## Genus level {.tabset}

```{r , message=FALSE, warning=FALSE, results='hide', echo=FALSE}
#-------------------------------------------------------------------------------
# MAASLIN: Extract data
#-------------------------------------------------------------------------------
# Filter out taxa that are prevalent in less than 25% 
out.folder <- "out/maaslin_final_genus/"
dir.create(out.folder)

# Glom phyloseq to genus level 
ps1.g <- tax_glom(ps1, taxrank = "Genus")

# Adjust tax names 
taxa_names(ps1.g) <- make.unique(phy_shorten_tax_names(ps1.g))

res.maas.long.g <-NULL

for (i in unique(ps1.meta[, Group]))  {
  
  ps.gr <- prune_samples(ps1.meta[, Group] == i, ps1.g)
  
  ps.gr <- tax_filt_phy(ps.gr, prev = maaslin.prev.cut, 
                        group_col = Time_point)
  
  ps.gr.asv <- ps.gr %>% 
                otu_table()  %>% 
                as.matrix()  %>% 
                as.data.frame() 
  
  ps.gr.meta <- ps.meta[ps1.meta[, Group] == i, ]
  
  maas.out <- Maaslin2(
                        input_data =  ps.gr.asv, 
                        input_metadata = ps.gr.meta, 
                        output = paste0(out.folder, i), 
                        fixed_effects = c(Time_point), 
                        random_effects = PersonID, 
                        reference = paste0(Time_point, ",", "TD1"), 
                        correction = "BH", 
                        cores = 4, 
                        min_abundance = 0, 
                        min_prevalence = 0, 
                        min_variance = 0, 
                        normalization = maaslin.norm.method, 
                        transform = maaslin.tranf.method, 
                        analysis_method = maaslin.analysis.method, 
                        max_significance = alpha)
  

res.maas.long.g <- rbind(res.maas.long.g, cbind(maas.out$results, Strata = i))  

}
```

### Results table

**Table.** The genera with significant changes between T1 and T3 as determine by MaAsLin2. Control and Treatment group were analysed separately. Only ASV with prevalence more than 25% in a time point were tested. Participant IDs were used as a random effect. 
```{r , message=FALSE, warning=FALSE, echo=FALSE}
tab.print <- res.maas.long.g[res.maas.long.g$qval < alpha, ]

kable(tab.print)
```

### Results cofficient figure

**Figure.** Visualization of the MaAsLin2 results. On the x-axis shown the coefficient of the abundance change after intervention on Genus level. 
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=6.5, fig.height=3}
res.maas.long.g <- res.maas.long.g[res.maas.long.g$qval < alpha, ]

maas.plot <- ggplot(res.maas.long.g, 
                        aes(x = coef, y = feature)) + 
                        geom_segment(aes(x = 0, xend = coef, 
                                     y = feature, yend = feature), 
                                     color = "black", alpha = 0.75) + 
                        geom_vline(xintercept = 0, alpha = 0.75) + 
                        geom_point(size = 3.5, alpha = 0.9) + 
                        facet_grid(. ~ Strata) + 
                        theme_bw() +
                        theme(panel.grid.major.x = element_blank(),
                              panel.grid.minor.x = element_blank(), 
                              axis.text.y = element_text(face = "italic")) +
                        ylab("") + xlab("Coeficient")

maas.plot
```

### Results boxplot

**Figure.** Box plots show relative abundance of genera identified as significantly different before and after intervention by MaAsLin2 per treatment group. 
```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.height=7.5, fig.width=4}
#-------------------------------------------------------------------------------
# Significant taxa as boxplots 
#-------------------------------------------------------------------------------

# Prepare data for plotting
da.taxa.df <- prune_taxa(res.maas.long.g$feature, ps1.css.genus) %>% 
              otu_table() %>%
              as.matrix() %>% 
              as.data.frame() %>% 
              mutate(Taxa = rownames(.)) %>% 
              gather(key = "SeqID", value = "Abundance", -Taxa) %>% 
              left_join(., mutate(ps1.meta, 
                                  SeqID=rownames(ps1.meta))[, c("SeqID", 
                                                                "Group", 
                                                                "Timepoint")], 
                          by = "SeqID") 


dif.abund.tax <- ggplot(da.taxa.df, aes_string(y = "Abundance", 
                                               x = "Timepoint")) + 
                  geom_jitter(aes_string(color = "Timepoint"), size = 2, 
                              alpha = 0.5, width = 0.25, height = 0) +
                  geom_boxplot(fill = "black", alpha = 0.1, outlier.colour = NA) +
                  facet_grid(c( "Taxa", "Group"), scales = "free") + 
                  theme_bw() + 
                  scale_color_manual(values = col.time.point) + 
                  theme(legend.position = "none") + 
                  ylab("Abundance (CSS)") + 
                  theme(strip.text.y = element_text(size = 4.5))
                  

dif.abund.tax
```

--------------------------------------------------------------------------------

# Correlational analysis. 

```{r , message=FALSE, warning=FALSE, echo=FALSE}

#-------------------------------------------------------------------------------
# Function: pairwise correlation 
#-------------------------------------------------------------------------------
corr_paired <- function(otu_tab,
                     df_to_corr,
                     corr_method = "spearman",
                     p_adj_method = "BH")  {

  final.res <- NULL

      for (i.cor.df in colnames(df_to_corr)) {

        i.cor.df.res <- NULL

        for (i.tax in colnames(otu_tab)) {

          i.cor.df.res <- cor.test(df_to_corr[, i.cor.df],
                                   otu_tab[, i.tax],
                                   method = corr_method,
                                   na.action = "na.omit") %>%
                            tidy() %>%
                            mutate(Taxa = i.tax) %>%
                            bind_rows(i.cor.df.res, .)

        }

        final.res <- i.cor.df.res %>%
                        mutate(cor.vec.name = i.cor.df,
                               qval = p.adjust(p.value, method = p_adj_method),
                               p.adj.method = p_adj_method) %>%
                        bind_rows(final.res, .)

      }
  
  return(final.res)

}

```

--------------------------------------------------------------------------------

## Delta TTE and delta bacteria

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
# Function: Find delta ASV 
#-------------------------------------------------------------------------------
pairs_delta_otu <- function(phy, pairs_col, sample_id_col) {
  # Extract dataframe 
  otu.tab <- phy %>% 
              otu_table() %>% 
              as.matrix() %>% 
              as.data.frame()
  
  if(taxa_are_rows(phy)) {
    
    otu.tab <- otu.tab %>% 
                  t() %>% 
                  as.data.frame()
    
  }
  
  # Extract metadata 
  meta <- phy %>% 
            sample_data() %>% 
            as.matrix() %>% 
            as.data.frame()
  
  
  comb <- bind_cols(otu.tab, meta[, c(pairs_col, sample_id_col)]) %>% 
              group_by(across(sample_id_col)) %>%
              arrange(across(pairs_col), .by_group = TRUE) %>%
              summarise(across(where(is.numeric), 
                               function(x){x[2] - x[1]}))
  
  return(comb)

}
```

### ASV level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.asv
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

gr <- c("GR1", "GR2")

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25  

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

gr <- "GR1"

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                filter(Rnr %in% rownames(TTE.data)) %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

phy.obj <- ps1.css.asv

gr <- "GR2"

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                filter(Rnr %in% rownames(TTE.data)) %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### Genus level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.genus
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

gr <- c("GR1", "GR2")

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25  

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

gr <- "GR1"

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                filter(Rnr %in% rownames(TTE.data)) %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.   \
```{r , message=FALSE, warning=FALSE, echo=FALSE}

cut.off <- 0.25

gr <- "GR2"

TTE.data <- ps.meta %>% 
              dplyr::filter(Timepoint == "TD1", 
                            Group %in% gr) %>% 
              select(c("Rnr", "Delta_TTE")) %>% 
              dplyr::arrange(across("Rnr")) %>% 
              column_to_rownames("Rnr")

tab.print <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "Group") %>% 
                pairs_delta_otu(pairs_col = "Timepoint", 
                                sample_id_col = "Rnr") %>% 
                filter(Rnr %in% rownames(TTE.data)) %>% 
                column_to_rownames("Rnr") %>% 
                corr_paired(., TTE.data) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```


--------------------------------------------------------------------------------

## Delta TTE and bacteria {.tabset}

### Per GR_TD; prev > 0.25; ASV

**Figure .** Top 5 correlations by estimate per group. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
phy.obj <- ps1.css.asv

cut.off <- 0.25

meta.cor.cols <- "Delta_TTE"

sel.n.rows <- 5
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = sel.n.rows)

kable(tab.print)
```

### Per GR_TD; prev > 0.25; Genus

**Figure .** Top 5 correlations by estimate per group. \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
phy.obj <- ps1.css.genus

cut.off <- 0.25

meta.cor.cols <- "Delta_TTE"

sel.n.rows <- 5
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = sel.n.rows)

kable(tab.print)
```

--------------------------------------------------------------------------------

## Delta TTE and delta SCFA {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
# SCFA dataframe 
scfa.df.delta <- ps.meta %>% 
                    select(c(grep("SCFA_", colnames(.)), 
                             "Rnr", "Timepoint", "Group", "Delta_TTE")) %>% 
                 group_by(Rnr) %>% 
                 arrange(Timepoint, .by_group = TRUE) %>%
                 mutate(across(grep("SCFA_", colnames(.)), 
                               function(x){x[2] - x[1]})) %>% 
                 filter(Timepoint == "TD1") %>% 
                 column_to_rownames("Rnr")
                 
```

### GR1 + GR2 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1", "GR2")
#-------------------------------------------------------------------------------

scfa.df.delta.gr <- scfa.df.delta %>% 
                       filter(Group %in% gr)

first.df <- scfa.df.delta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- scfa.df.delta.gr %>% 
              select(Delta_TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### GR1 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1")
#-------------------------------------------------------------------------------

scfa.df.delta.gr <- scfa.df.delta %>% 
                       filter(Group %in% gr)

first.df <- scfa.df.delta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- scfa.df.delta.gr %>% 
              select(Delta_TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### GR2 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR2")
#-------------------------------------------------------------------------------

scfa.df.delta.gr <- scfa.df.delta %>% 
                       filter(Group %in% gr)

first.df <- scfa.df.delta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- scfa.df.delta.gr %>% 
              select(Delta_TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

--------------------------------------------------------------------------------

## Delta TTE and SCFA

### GR_TD 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
# SCFA dataframe 

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  first.df <- ps.meta %>% 
                select(c(grep("SCFA_", colnames(.)), "GR_TD")) %>% 
                filter(GR_TD == gr) %>% 
                select(-GR_TD)
  
  second.df <- ps.meta %>% 
                select(c("Delta_TTE", "GR_TD")) %>% 
                filter(GR_TD == gr) %>% 
                select(-GR_TD)
  
  tab.print <- corr_paired(first.df, second.df ) %>% 
                mutate(Group = gr) %>% 
                bind_rows(tab.print, .)
  
}


tab.print.f <- tab.print %>% 
                  group_by(Group) %>% 
                  slice_max(order_by = abs(estimate), n = 5) %>% 
                  ungroup()
  
kable(tab.print.f)
```

--------------------------------------------------------------------------------

## TTE and Bacteria

### ASV level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.asv
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR1", "GR2")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR1")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR2")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### GR_TD; prev > 0.25 

**Figure .** Top 5 correlations by estimate per group.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = 5)

kable(tab.print)
```

### Genus level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.genus
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR1", "GR2")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR1")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

gr <- c("GR2")

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### GR_TD; prev > 0.25 

**Figure .** Top 20 correlations by estimate per group.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25

meta.cor.cols <- "TTE"
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = 5)

kable(tab.print)
```


```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
# A helper function - short tidy results from corr.test results 
#-------------------------------------------------------------------------------
tidy_corr_res <- function(corr_results) {
  
    corr.tidy <- corr_results[["p"]] %>% 
                    as.data.frame() %>% 
                    rownames_to_column() %>% 
                    gather(key = "key", value = "p_value", -rowname) %>% 
                    mutate(p_adj = c(corr_results[["p.adj"]]), 
                           r = c(corr_results[["r"]]))
  
  return(corr.tidy)
}
```

--------------------------------------------------------------------------------

## TTE and SCFA {.tabset}

### GR1 + GR2 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1", "GR2")
#-------------------------------------------------------------------------------

ps.meta.gr <- ps.meta %>% 
                       filter(Group %in% gr)

first.df <- ps.meta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- ps.meta.gr %>% 
              select(TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### GR1 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1")
#-------------------------------------------------------------------------------

ps.meta.gr <- ps.meta %>% 
                       filter(Group %in% gr)

first.df <- ps.meta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- ps.meta.gr %>% 
              select(TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### GR2 

```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR2")
#-------------------------------------------------------------------------------

ps.meta.gr <- ps.meta %>% 
                       filter(Group %in% gr)

first.df <- ps.meta.gr %>% 
              select(grep("SCFA_", colnames(.)))

second.df <- ps.meta.gr %>% 
              select(TTE)

tab.print <- corr_paired(first.df, second.df ) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

### GR_TD

```{r , message=FALSE, warning=FALSE, echo=FALSE}
# SCFA dataframe 

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  first.df <- ps.meta %>% 
                select(c(grep("SCFA_", colnames(.)), "GR_TD")) %>% 
                filter(GR_TD == gr) %>% 
                select(-GR_TD)
  
  second.df <- ps.meta %>% 
                select(c("TTE", "GR_TD")) %>% 
                filter(GR_TD == gr) %>% 
                select(-GR_TD)
  
  tab.print <- corr_paired(first.df, second.df ) %>% 
                mutate(Group = gr) %>% 
                bind_rows(tab.print, .)
  
}


tab.print.f <- tab.print %>% 
                  group_by(Group) %>% 
                  slice_max(order_by = abs(estimate), n = 5) %>% 
                  ungroup()
  
kable(tab.print.f)
```

--------------------------------------------------------------------------------

## SCFA and Bacteria 

### ASV level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.asv

meta.cor.cols <- grep("SCFA_", colnames(ps.meta), value = TRUE)

cut.off <- 0.25
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1", "GR2")
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1")
#-------------------------------------------------------------------------------

second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR2")
#-------------------------------------------------------------------------------

second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### GR_TD; prev > 0.25 

**Figure .** Top 10 correlations by estimate per group.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = 10)

kable(tab.print)
```


### Genus level {.tabset}

```{r , message=FALSE, warning=FALSE, echo=FALSE}
phy.obj <- ps1.css.genus

meta.cor.cols <- grep("SCFA_", colnames(ps.meta), value = TRUE)

cut.off <- 0.25
```

#### Gr1+Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1", "GR2")
#-------------------------------------------------------------------------------


second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr1; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR1")
#-------------------------------------------------------------------------------

second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### Gr2; prev > 0.25 

**Figure .** Top 10 correlations by estimate.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
gr <- c("GR2")
#-------------------------------------------------------------------------------

second.df <- ps.meta %>% 
              dplyr::filter(Group %in% gr) %>% 
              select(c("SeqID", meta.cor.cols)) %>% 
              column_to_rownames("SeqID")

otu.tab <- phy.obj %>% 
              tax_filt_phy(prev = cut.off, 
                           group_col = "Group") %>% 
              prune_samples(ps.meta$Group %in% gr, .) %>% 
              otu_table() %>% 
              as.matrix() %>% 
              t() %>% 
              as.data.frame()

if(!identical(rownames(second.df), rownames(otu.tab))) {
  
  stop("Row names are not matching") }
  
tab.print <-  corr_paired(otu.tab, second.df) %>% 
                arrange(desc(abs(estimate))) %>% 
                # filter(qval <= 0.1) %>% 
                slice_head(n = 10)

kable(tab.print)
```

#### GR_TD; prev > 0.25 

**Figure .** Top 10 correlations by estimate per group.  \
```{r , message=FALSE, warning=FALSE, echo=FALSE}
#-------------------------------------------------------------------------------
cut.off <- 0.25
#-------------------------------------------------------------------------------

tab.print <- NULL

for (gr in unique(ps.meta$GR_TD)) {
  
  second.df <- ps.meta %>% 
                  dplyr::filter(GR_TD %in% gr) %>% 
                  select(c("SeqID", meta.cor.cols)) %>% 
                  column_to_rownames("SeqID")

  otu.tab <- phy.obj %>% 
                tax_filt_phy(prev = cut.off, 
                             group_col = "GR_TD") %>% 
                prune_samples(ps.meta$GR_TD %in% gr, .) %>% 
                otu_table() %>% 
                as.matrix() %>% 
                t() %>% 
                as.data.frame()

  if(!identical(rownames(second.df), rownames(otu.tab))) {
    
    stop("Row names are not matching") }
    
  tab.print <- corr_paired(otu.tab, second.df) %>% 
                  arrange(desc(abs(estimate))) %>% 
                  mutate(Group = gr) %>% 
                  bind_rows(tab.print, .)
  
}

tab.print <- tab.print %>% 
                group_by(Group) %>% 
                slice_max(order_by = abs(estimate), n = 10)

kable(tab.print)
```




--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

# Differences in SCFA between T1 and T3 in GR1 and GR2 

### Comparition using paired Wilcoxon test

\
**Table .** Significant test results (p <= 0.05) of SCFA concentrations comparison between T1 and T3 per group with paired Wilcoxon test. 
```{r , message=FALSE, warning=FALSE, echo=FALSE}
scfa.wlic.res <- NULL

for(i in unique(ps1.meta[, Group])) {
  
gr.meta <- ps1.meta %>% 
              filter((!!sym(Group)) == i) %>% 
              group_by((!!sym(PersonID))) %>% 
              filter(n() == 2)  %>%
              arrange(across(c(PersonID, Time_point)), .by_group = TRUE) %>% 
              group_by((!!sym(Time_point))) %>% 
              group_split()
  
  for (i1 in grep("SCFA", colnames(ps1.meta), value = TRUE)) {
    
    scfa.wlic.res <- wilcox.test(pull(gr.meta[[1]], i1), 
                                  pull(gr.meta[[2]], i1), 
                                  paired = TRUE) %>% 
                        tidy() %>% 
                        mutate(Group = i, SCFA = i1) %>% 
                        rbind(scfa.wlic.res, .)
    
  }
}

scfa.wlic.res[scfa.wlic.res$p.value <= 0.05, ] %>% 
  select(c("statistic", "p.value", "alternative", "Group", "SCFA")) %>% 
  as.data.frame()
```

**Figure .** The boxplots show differences in SCFA concentrations between T1 and T3 per group. Significance of the difference is assessed by paired Wilcoxon test. 
```{r , message=FALSE, warning=FALSE, echo=FALSE}

scfa.wlic.res.sig <- scfa.wlic.res[scfa.wlic.res$p.value < 0.05, ]

#-------------------------------------------------------------------------------
# Plot SCFA per group 
#-------------------------------------------------------------------------------
scfa.p.df <- ps1.meta %>% 
                  select(c(PersonID, Time_point, Group, 
                           grep("SCFA", colnames(.), value = TRUE))) %>% 
                  gather(key = "SCFA", value = "Concentraion", 
                         -all_of(c(PersonID, Time_point, Group))) 


# Make data frame for significance levels 
max.div <- scfa.p.df %>% 
              group_by(across(c(Group, "SCFA"))) %>% 
              slice(which.max(Concentraion)) %>% 
              mutate(Id = paste0(SCFA, "_", Group), 
                     End = if_else(Timepoint == "TD1", "TD3", "TD1"), 
                     y = Concentraion*1.1)

sig.df <- scfa.wlic.res.sig %>% 
            mutate(Id = paste0(SCFA, "_", Group), 
                   p.short = paste0("p=", round(p.value, 3))) %>% 
            filter(p.value <= 0.05) %>% 
            left_join(., max.div)

# Plot alpha diversity 
scfa.plot <- ggplot(scfa.p.df, aes(y = Concentraion, x = Timepoint)) + 
                  geom_point(size = 2, alpha = 1) +
                  geom_line(aes_string(group = PersonID), alpha = 0.25) + 
                  geom_boxplot(fill = "black", alpha = 0.1) +
                  geom_signif(data = sig.df,
                              aes(xmin = Timepoint,
                                  xmax = End,
                                  annotations = p.short,
                                  y_position = y),
                              textsize = 4, vjust = -0.1,
                              manual = TRUE, margin_top = 1) +
                  geom_point(data = sig.df,
                              aes(x = End, y = y*1.175), x=NA) +
                  facet_grid(SCFA ~ Group, scales = "free") + 
                  theme_bw()
```

```{r , message=FALSE, warning=FALSE, echo=FALSE, fig.width=6, fig.height=9}
scfa.plot
```

### Comparition using Linear Mix Model 

\
**Table .** Results of LMM with formula SCFA ~ Group*Time_point + (1|PersonID). 
```{r , message=FALSE, warning=FALSE, echo=FALSE}
scfa.lmm.ls <- list()

scfa.summ.ls <- NULL

for (i in grep("SCFA", colnames(ps1.meta), value = TRUE)) {
  
  mod.form <- paste0(i, " ~ ", 
                         Group, "*", Time_point, "+",
                         "(1|", PersonID, ")") 

  mod.res <- lmerTest::lmer(mod.form, data = ps1.meta) 
  
  scfa.lmm.ls[[i]] <- mod.res

  scfa.summ.ls[[i]] <- broom.mixed::tidy(mod.res, 
                            effects="fixed", 
                            conf.int=TRUE, 
                            conf.level = 0.95) %>% 
                            mutate(SCFA = i, 
                                   p_val = round(.$p.value, 3)) %>% 
                            as.data.frame()
}
```

```{r , message=FALSE, warning=FALSE, echo=FALSE}
scfa.summ.ls
```